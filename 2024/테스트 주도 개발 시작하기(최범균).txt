▶리뷰
이전에 클린 코드 도서를 읽으면서 자연스레 테스트 코드에 대해서도 공부하게 되었다. 사실, 테스트 코드에 대해 항상 궁금했다. 단순히 호기심을 말하는게 아니라 도대체 어떻게 작성을 해야하는가! 검색을 해보면 계산기나 클릭 이벤트같이 아주 쉽고 단순한 예시들이 나온다. 혹은 너무 복잡하거나. 나에게 맞는 적절한 예시를 찾기 힘들었기에 공부시간보다는 검색 시간이 더 많았다. 내 검색 실력이 부족해서 그럴 수도 있지만. 그래서 테스트 코드를 작성해도 구현하기 보다 흉내내는 수준으로 작성을 하고 있었다. 이번 기회에 제대로 이해하자고 마음 먹었다.

이 책은 테스트 주도 개발, TDD에 관한 책이다. 그러니까 테스트 코드를 먼저 작성하고 기능을 구현하는 개발 방식이다. 그러기에 테스트 작성 방법을 더욱 찬찬히 알려주고 있다. TDD 방식과 더불어 TDD를 하기 위한 테스트 코드 작성법을 자세히 알려준다. 다양한 예시 코드와 함께 설명하고 있기에 옆에서 작성하는 모습을 구경하는 기분이 든다.  

또한 테스트 코드도 결국 코드이기 때문에 코드 리팩토링도 볼 수 있다. 하나의 책임을 지게하기 위해 어떻게 추출하는지, 의존도를 줄이는지 볼 수 있다. 이 정도면 괜찮지 않을까 싶은 상황에도 리팩토링 모습을 보면 이렇게 코드를 작성해야했구나 반성하게 되었다. 전/후 코드를 보는 것보다는 하나씩 따라가며 완성되어 가는 과정을 볼 수 있기에 확실히 더 와닿았다. 

개인적으로 이 책은 추천할만하다. 특히 나같이 테스트 코드를 어떻게 작성하는지 궁금한 사람 속을 시원하게 만들어준다. 평소 TDD에 대한 이해도 부족했기에 테스트 작성 후 기능 구현이라니 무슨 해괴한 방법이지 라고 생각한 내가 바보 같아졌다. 작성 방법을 이해하고 필요성에 대해서도 절실히 느낄 수 있기에 얼른 적용하고 싶어졌다. 물론 그 전에 할 일을 얼른 끝내야겠지만 ㅎㅎ. 공부를 하면 할 수록 다시 공부할 내용이 점점 늘어가지만 그래도 배운 내용을 얼른 활용하고 싶은 걸 보니 역시 개발에 잘 맞기는 한가보다. 짐은 늘었지만 어쩐지 개발에 대한 동기부여를 얻을 수 있었다.


▶기억하고 싶은 내용

테스트 코드 작성이란
- TDD는 테스트 코딩 리팩토링의 무한반복
- 테스트 코드의 구성은 클래스 이름, 메서드 이름, 메서드 파라미터, 실행결과. 이 네 가지를 결정하는 과정은 설계 과정과 비슷. TDD 자체는 설계가 아니지만 설계 일부분을 진행.
- 모호한 상황을 만나면 이를 구체적인 예로 바꾸어 테스트 코드에 반영. 즉, 테스트 코드는 예를 이용한 구체적인 명세.
- 테스트 코드의 기본 골격은 상황(given), 실행(when), 결과확인(then)
   예. 정답이 4인 상황에서 실행 후 결과 확인
- 리팩토링을 할 때 기존의 메서드에서 새로 만든 메서드를 호출한 뒤 성공하면 기존 메서드 삭제. 기존 메서드 대신 새로 만든 메서드를 바로 호출하면 문제 발생 시 수정해야할 부분이 많아지기 때문

테스트 코드 작성 전 주의점
- 빌더 패턴 사용 고려
- 첫 번째 테스트를 선택할 때에는 가장 쉽거나 예외적인 상황을 선택
- TDD는 테스트를 통과시킬 만큼의 코드만 작성. 필요할 것으로 예측해서 미리 코드를 만들지 않음.
- 범위가 큰 리팩토링은 시간이 오래 걸리므로 TDD 흐름을 깨기 쉽움. 이때는 리팩토링을 진행하지 말고 테스트를 통과시키는데 집중. 추후 진행.
- 테스트 코드 작성이 어려울 때는 assert 부터 작성하며 역순으로 진행
- 테스트 코드 진행이 힘들 때는 미련없이 삭제 후 재시작. 올바른 순서로 작성하고 있는지 확인 후 재작성.

테스트 코드 구현 주의점
- JUnit이 테스트 순서를 결정하긴 하지만 그 순서는 버전에 따라 달라질 수 있음.
- 외부 상태에 따라 테스트의 성공 여부가 바뀌지 않아야함. 테스트 실행 전에 외부를 원하는 상태로 만들거나 테스트 실행 후에 외부 상태를 원래대로 되돌려 놓아야함
   예. 데이터 삭제 후 원래 데이터를 되돌려놔야함.
- 내부 구현은 언제든지 바뀔 수 있기 때문에 테스트 코드는 내부 구현 검증보다 실행 결과에 집중
- BeforeEach같이 셋업으로 중복된 상황 설정 조심. 모든 테스트 메서드에 동일한 상황 코드를 공유하기 때문에 조금만 변경되어도 테스트가 깨지기 쉬운 구조로 됨. 각 메서드 안에 위치시키도록함.
- 조건부 추가 보다 조건에 대한 단언 추가 고려. 
   예. if(items.size()>0) assertEquals(1,items,get(0); -> assertTrue(items.size()>0); assertEquals(1,items,get(0);

대역
- test double는 테스트에서 진짜 대신 사용할 대역을 의미
- 대역 종류(stub, fake, spy, mock)
- 제어하기 힘든 외부 상황이 존재하면 다음과 같은 방법으로 의존을 도출하고 이를 대역으로 대체. 
  1)제어하기 힘든 외부 상황을 별도 타입으로 분리
  2)테스트 코드는 별도로 분리된 타입의 대역 생성
  3)생성한 대역을 테스트 대상자의 생성자 등을 이용하여 전달
  4)대역을 이용하여 상황 구성
- 모의 객체는 기본적으로 메서드 호출 여부 검증 수단. 결과 검증 수단에는 부적절. 저장소에 대한 대역은 모의 객체보다는 가짜 구현이 유리.
- 모의 객체에서 anyString()같이 임의 값 지정하기. 동작만 확인하기 때문에 작은 변화에도 불필요한 실패를 낳을 수 있음.


▶추가 공부하고 싶은 내용 
- 레거시 코드 활용 전략(마이클 C. 페더스)