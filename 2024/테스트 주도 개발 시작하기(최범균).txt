- 첫 번째 테스트를 선택할 때에는 가장 쉽거나 예외적인 상황을 선택
- TDD는 테스트를 통과시킬 만큼의 코드만 작성
- TDD는 테스트 코딩 리팩토링의 무한반복
- 리팩토링을 할 때 기존의 메서드에서 새로 만든 메서드를 호출한 뒤 성공하면 기존 메서드 삭제. 바로 기존 메서드 대신 새로 만든 메서드를 호출하면 문제 발생 시 수정해야할 부분이 많아지기 때문
- 빌더 패턴 사용 고려
- 범위가 큰 리팩토링은 시간이 오래 걸리므로 TDD 흐름을 깨기 쉽다. 이때는 리팩토링을 진행하지 말고 테스트를 통과시키는데 집중. 추후 진행
- 테스트 코드 작성이 어려울 때는 assert 부터 작성하며 역순으로 진행
- 테스트 코드 진행이 힘들 때는 미련없이 삭제 후 재시작. 올바른 순서로 작성하고 있는지 확인 후 재작성
- 테스트 코드의 클래스 이름, 메서드 이름, 메서드 파라미터, 실행결과. 이 네 가지를 결정하는 과정이 설계 과정. TDD 자체는 설계가 아니지만 설계 일부분을 진행.
- 필요할 것으로 예측해서 미리 코드를 만들지 않는다.
- 모호한 상황을 만나면 이를 구체적인 예로 바꾸어 테스트 코드에 반영. 즉, 테스트 코드는 예를 이용한 구체적인 명세.
- JUnit이 테스트 순서를 결정하긴 하지만 그 순서는 버전에 따라 달라질 수 있음.
- 테스트 코드의 기본 골격은 상황(given), 실행(when), 결과확인(then). 정답이 4인 상황에서 실행 후 결과 확인
- 외부 상태에 따라 테스트의 성공 여부가 바뀌지 않으려면 테스트 실행 전에 외부를 원하는 상태로 만들거나 테스트 실행 후에 외부 상태를 원래대로 되돌려 놓아야한다. 예를 들어 데이터 삭제 후 원래 데이터를 되돌려놔야함
- test double는 테스트에서 진짜 대신 사용할 대역을 의미
- 대역 종류(stub, fake, spy, mock)
- 제어하기 힘든 외부 상황이 존재하면 다음과 같은 방법으로 의존을 도출하고 이를 대역으로 대체. 제어하기 힘든 외부 상황을 별도 타입으로 분리, 테스트 코드는 별도로 분리된 타입의 대역 생성, 생성한 대역을 테스트 대상자의 생성자 등을 이용하여 전달, 대역을 이용하여 상황 구성
- 모의 객체는 기본적으로 메서드 호출 여부 검증 수단. 결과 검증 수단에는 부적절. 저장소에 대한 대역은 모의 객체보다는 가짜 구현이 유리.
- 결과 확인에서 기대값을 변수 사용 금지. 변수 값을 다시 확인해야해서 흐름이 복잡해짐.
- 모의 객체에서 anyString()같이 임의 값 지정하기. 동작만 확인하기 때문에 작은 변화에도 불필요한 실패를 낳을 수 있음.
- 내부 구현은 언제든지 바뀔 수 있기 때문에 테스트 코드는 내부 구현 검증보다 실행 결과에 집중
- BeforeEach같이 셋업으로 중복된 상황 설정 조심. 모든 테스트 메서드에 동일한 상황 코드를 공유하기 때문에 조금만 변경되어도 테스트가 깨지기 쉬운 구조로 됨. 각 메서드 안에 위치시키도록함.
- 조건부문을 추가하기 보다 조건에 대한 단언 추가 고려. if(items.size()>0) assertEquals(1,items,get(0); -> assertTrue(items.size()>0); assertEquals(1,items,get(0);
- 레거시 코드 활용 전략 책 읽어보기

테스트 코드 보면 하나의 책임 원칙 잘 보임. 의존도 줄임. 